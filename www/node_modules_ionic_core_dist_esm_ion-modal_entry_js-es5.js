(function () {
  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

  function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  (self["webpackChunkyou2me_ionic"] = self["webpackChunkyou2me_ionic"] || []).push([["node_modules_ionic_core_dist_esm_ion-modal_entry_js"], {
    /***/
    71855: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "ion_modal": function ion_modal() {
          return (
            /* binding */
            Modal
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./index-8fc7a46a.js */
      90245);
      /* harmony import */


      var _ionic_global_e0b8d325_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./ionic-global-e0b8d325.js */
      8688);
      /* harmony import */


      var _framework_delegate_780bd731_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./framework-delegate-780bd731.js */
      25877);
      /* harmony import */


      var _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! ./helpers-684323ee.js */
      18146);
      /* harmony import */


      var _overlays_0d94a120_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! ./overlays-0d94a120.js */
      84395);
      /* harmony import */


      var _theme_ff3fc52f_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! ./theme-ff3fc52f.js */
      61269);
      /* harmony import */


      var _index_f51621dd_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! ./index-f51621dd.js */
      19801);
      /* harmony import */


      var _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! ./animation-46ad1639.js */
      59670);
      /* harmony import */


      var _cubic_bezier_eea9a7a9_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
      /*! ./cubic-bezier-eea9a7a9.js */
      57807);
      /* harmony import */


      var _index_34cb2743_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
      /*! ./index-34cb2743.js */
      39461);
      /* harmony import */


      var _hardware_back_button_4a6b37fb_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
      /*! ./hardware-back-button-4a6b37fb.js */
      23087);
      /* harmony import */


      var _gesture_controller_31cb6bb9_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
      /*! ./gesture-controller-31cb6bb9.js */
      40960); // Defaults for the card swipe animation


      var SwipeToCloseDefaults = {
        MIN_PRESENTING_SCALE: 0.93
      };

      var createSwipeToCloseGesture = function createSwipeToCloseGesture(el, animation, onDismiss) {
        var height = el.offsetHeight;
        var isOpen = false;

        var canStart = function canStart(detail) {
          var target = detail.event.target;

          if (target === null || !target.closest) {
            return true;
          }

          var contentOrFooter = target.closest('ion-content, ion-footer');

          if (contentOrFooter === null) {
            return true;
          } // Target is in the content or the footer so do not start the gesture.
          // We could be more nuanced here and allow it for content that
          // does not need to scroll.


          return false;
        };

        var onStart = function onStart() {
          animation.progressStart(true, isOpen ? 1 : 0);
        };

        var onMove = function onMove(detail) {
          var step = (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.j)(0.0001, detail.deltaY / height, 0.9999);
          animation.progressStep(step);
        };

        var onEnd = function onEnd(detail) {
          var velocity = detail.velocityY;
          var step = (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.j)(0.0001, detail.deltaY / height, 0.9999);
          var threshold = (detail.deltaY + velocity * 1000) / height;
          var shouldComplete = threshold >= 0.5;
          var newStepValue = shouldComplete ? -0.001 : 0.001;

          if (!shouldComplete) {
            animation.easing('cubic-bezier(1, 0, 0.68, 0.28)');
            newStepValue += (0, _cubic_bezier_eea9a7a9_js__WEBPACK_IMPORTED_MODULE_8__.g)([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];
          } else {
            animation.easing('cubic-bezier(0.32, 0.72, 0, 1)');
            newStepValue += (0, _cubic_bezier_eea9a7a9_js__WEBPACK_IMPORTED_MODULE_8__.g)([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];
          }

          var duration = shouldComplete ? computeDuration(step * height, velocity) : computeDuration((1 - step) * height, velocity);
          isOpen = shouldComplete;
          gesture.enable(false);
          animation.onFinish(function () {
            if (!shouldComplete) {
              gesture.enable(true);
            }
          }).progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);

          if (shouldComplete) {
            onDismiss();
          }
        };

        var gesture = (0, _index_34cb2743_js__WEBPACK_IMPORTED_MODULE_9__.createGesture)({
          el: el,
          gestureName: 'modalSwipeToClose',
          gesturePriority: 40,
          direction: 'y',
          threshold: 10,
          canStart: canStart,
          onStart: onStart,
          onMove: onMove,
          onEnd: onEnd
        });
        return gesture;
      };

      var computeDuration = function computeDuration(remaining, velocity) {
        return (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.j)(400, remaining / Math.abs(velocity * 1.1), 500);
      };
      /**
       * Use y = mx + b to
       * figure out the backdrop value
       * at a particular x coordinate. This
       * is useful when the backdrop does
       * not begin to fade in until after
       * the 0 breakpoint.
       */


      var getBackdropValueForSheet = function getBackdropValueForSheet(x, backdropBreakpoint) {
        /**
         * We will use these points:
         * (backdropBreakpoint, 0)
         * (maxBreakpoint, 1)
         * We know that at the beginning breakpoint,
         * the backdrop will be hidden. We also
         * know that at the maxBreakpoint, the backdrop
         * must be fully visible. maxBreakpoint should
         * always be 1 even if the maximum value
         * of the breakpoints array is not 1 since
         * the animation runs from a progress of 0
         * to a progress of 1.
         * m = (y2 - y1) / (x2 - x1)
         *
         * This is simplified from:
         * m = (1 - 0) / (maxBreakpoint - backdropBreakpoint)
         */
        var slope = 1 / (1 - backdropBreakpoint);
        /**
         * From here, compute b which is
         * the backdrop opacity if the offset
         * is 0. If the backdrop does not
         * begin to fade in until after the
         * 0 breakpoint, this b value will be
         * negative. This is fine as we never pass
         * b directly into the animation keyframes.
         * b = y - mx
         * Use a known point: (backdropBreakpoint, 0)
         * This is simplified from:
         * b = 0 - (backdropBreakpoint * slope)
         */

        var b = -(backdropBreakpoint * slope);
        /**
         * Finally, we can now determine the
         * backdrop offset given an arbitrary
         * gesture offset.
         */

        return x * slope + b;
      };

      var createSheetEnterAnimation = function createSheetEnterAnimation(opts) {
        var currentBreakpoint = opts.currentBreakpoint,
            backdropBreakpoint = opts.backdropBreakpoint;
        /**
         * If the backdropBreakpoint is undefined, then the backdrop
         * should always fade in. If the backdropBreakpoint came before the
         * current breakpoint, then the backdrop should be fading in.
         */

        var shouldShowBackdrop = backdropBreakpoint === undefined || backdropBreakpoint < currentBreakpoint;
        var initialBackdrop = shouldShowBackdrop ? "calc(var(--backdrop-opacity) * ".concat(currentBreakpoint, ")") : '0.01';
        var backdropAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)('backdropAnimation').fromTo('opacity', 0, initialBackdrop);
        var wrapperAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)('wrapperAnimation').keyframes([{
          offset: 0,
          opacity: 1,
          transform: 'translateY(100%)'
        }, {
          offset: 1,
          opacity: 1,
          transform: "translateY(".concat(100 - currentBreakpoint * 100, "%)")
        }]);
        return {
          wrapperAnimation: wrapperAnimation,
          backdropAnimation: backdropAnimation
        };
      };

      var createSheetLeaveAnimation = function createSheetLeaveAnimation(opts) {
        var currentBreakpoint = opts.currentBreakpoint,
            backdropBreakpoint = opts.backdropBreakpoint;
        /**
         * Backdrop does not always fade in from 0 to 1 if backdropBreakpoint
         * is defined, so we need to account for that offset by figuring out
         * what the current backdrop value should be.
         */

        var backdropValue = "calc(var(--backdrop-opacity) * ".concat(getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint), ")");
        var defaultBackdrop = [{
          offset: 0,
          opacity: backdropValue
        }, {
          offset: 1,
          opacity: 0
        }];
        var customBackdrop = [{
          offset: 0,
          opacity: backdropValue
        }, {
          offset: backdropBreakpoint,
          opacity: 0
        }, {
          offset: 1,
          opacity: 0
        }];
        var backdropAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)('backdropAnimation').keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);
        var wrapperAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)('wrapperAnimation').keyframes([{
          offset: 0,
          opacity: 1,
          transform: "translateY(".concat(100 - currentBreakpoint * 100, "%)")
        }, {
          offset: 1,
          opacity: 1,
          transform: "translateY(100%)"
        }]);
        return {
          wrapperAnimation: wrapperAnimation,
          backdropAnimation: backdropAnimation
        };
      };

      var createEnterAnimation$1 = function createEnterAnimation$1() {
        var backdropAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().fromTo('opacity', 0.01, 'var(--backdrop-opacity)');
        var wrapperAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().fromTo('transform', 'translateY(100vh)', 'translateY(0vh)');
        return {
          backdropAnimation: backdropAnimation,
          wrapperAnimation: wrapperAnimation
        };
      };
      /**
       * iOS Modal Enter Animation for the Card presentation style
       */


      var iosEnterAnimation = function iosEnterAnimation(baseEl, opts) {
        var presentingEl = opts.presentingEl,
            currentBreakpoint = opts.currentBreakpoint;
        var root = (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.g)(baseEl);

        var _ref = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation$1(),
            wrapperAnimation = _ref.wrapperAnimation,
            backdropAnimation = _ref.backdropAnimation;

        backdropAnimation.addElement(root.querySelector('ion-backdrop')).beforeStyles({
          'pointer-events': 'none'
        }).afterClearStyles(['pointer-events']);
        wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({
          'opacity': 1
        });
        var baseAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)('entering-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(500).addAnimation(wrapperAnimation);

        if (presentingEl) {
          var isMobile = window.innerWidth < 768;
          var hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;
          var presentingElRoot = (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.g)(presentingEl);
          var presentingAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().beforeStyles({
            'transform': 'translateY(0)',
            'transform-origin': 'top center',
            'overflow': 'hidden'
          });
          var bodyEl = document.body;

          if (isMobile) {
            /**
             * Fallback for browsers that does not support `max()` (ex: Firefox)
             * No need to worry about statusbar padding since engines like Gecko
             * are not used as the engine for standalone Cordova/Capacitor apps
             */
            var transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';
            var modalTransform = hasCardModal ? '-10px' : transformOffset;
            var toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
            var finalTransform = "translateY(".concat(modalTransform, ") scale(").concat(toPresentingScale, ")");
            presentingAnimation.afterStyles({
              'transform': finalTransform
            }).beforeAddWrite(function () {
              return bodyEl.style.setProperty('background-color', 'black');
            }).addElement(presentingEl).keyframes([{
              offset: 0,
              filter: 'contrast(1)',
              transform: 'translateY(0px) scale(1)',
              borderRadius: '0px'
            }, {
              offset: 1,
              filter: 'contrast(0.85)',
              transform: finalTransform,
              borderRadius: '10px 10px 0 0'
            }]);
            baseAnimation.addAnimation(presentingAnimation);
          } else {
            baseAnimation.addAnimation(backdropAnimation);

            if (!hasCardModal) {
              wrapperAnimation.fromTo('opacity', '0', '1');
            } else {
              var _toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;

              var _finalTransform = "translateY(-10px) scale(".concat(_toPresentingScale, ")");

              presentingAnimation.afterStyles({
                'transform': _finalTransform
              }).addElement(presentingElRoot.querySelector('.modal-wrapper')).keyframes([{
                offset: 0,
                filter: 'contrast(1)',
                transform: 'translateY(0) scale(1)'
              }, {
                offset: 1,
                filter: 'contrast(0.85)',
                transform: _finalTransform
              }]);
              var shadowAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().afterStyles({
                'transform': _finalTransform
              }).addElement(presentingElRoot.querySelector('.modal-shadow')).keyframes([{
                offset: 0,
                opacity: '1',
                transform: 'translateY(0) scale(1)'
              }, {
                offset: 1,
                opacity: '0',
                transform: _finalTransform
              }]);
              baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
            }
          }
        } else {
          baseAnimation.addAnimation(backdropAnimation);
        }

        return baseAnimation;
      };

      var createLeaveAnimation$1 = function createLeaveAnimation$1() {
        var backdropAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().fromTo('opacity', 'var(--backdrop-opacity)', 0);
        var wrapperAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().fromTo('transform', 'translateY(0vh)', 'translateY(100vh)');
        return {
          backdropAnimation: backdropAnimation,
          wrapperAnimation: wrapperAnimation
        };
      };
      /**
       * iOS Modal Leave Animation
       */


      var iosLeaveAnimation = function iosLeaveAnimation(baseEl, opts) {
        var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;
        var presentingEl = opts.presentingEl,
            currentBreakpoint = opts.currentBreakpoint;
        var root = (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.g)(baseEl);

        var _ref2 = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation$1(),
            wrapperAnimation = _ref2.wrapperAnimation,
            backdropAnimation = _ref2.backdropAnimation;

        backdropAnimation.addElement(root.querySelector('ion-backdrop'));
        wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({
          'opacity': 1
        });
        var baseAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)('leaving-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(duration).addAnimation(wrapperAnimation);

        if (presentingEl) {
          var isMobile = window.innerWidth < 768;
          var hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;
          var presentingElRoot = (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.g)(presentingEl);
          var presentingAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().beforeClearStyles(['transform']).afterClearStyles(['transform']).onFinish(function (currentStep) {
            // only reset background color if this is the last card-style modal
            if (currentStep !== 1) {
              return;
            }

            presentingEl.style.setProperty('overflow', '');
            var numModals = Array.from(bodyEl.querySelectorAll('ion-modal')).filter(function (m) {
              return m.presentingElement !== undefined;
            }).length;

            if (numModals <= 1) {
              bodyEl.style.setProperty('background-color', '');
            }
          });
          var bodyEl = document.body;

          if (isMobile) {
            var transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';
            var modalTransform = hasCardModal ? '-10px' : transformOffset;
            var toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
            var finalTransform = "translateY(".concat(modalTransform, ") scale(").concat(toPresentingScale, ")");
            presentingAnimation.addElement(presentingEl).keyframes([{
              offset: 0,
              filter: 'contrast(0.85)',
              transform: finalTransform,
              borderRadius: '10px 10px 0 0'
            }, {
              offset: 1,
              filter: 'contrast(1)',
              transform: 'translateY(0px) scale(1)',
              borderRadius: '0px'
            }]);
            baseAnimation.addAnimation(presentingAnimation);
          } else {
            baseAnimation.addAnimation(backdropAnimation);

            if (!hasCardModal) {
              wrapperAnimation.fromTo('opacity', '1', '0');
            } else {
              var _toPresentingScale2 = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;

              var _finalTransform2 = "translateY(-10px) scale(".concat(_toPresentingScale2, ")");

              presentingAnimation.addElement(presentingElRoot.querySelector('.modal-wrapper')).afterStyles({
                'transform': 'translate3d(0, 0, 0)'
              }).keyframes([{
                offset: 0,
                filter: 'contrast(0.85)',
                transform: _finalTransform2
              }, {
                offset: 1,
                filter: 'contrast(1)',
                transform: 'translateY(0) scale(1)'
              }]);
              var shadowAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().addElement(presentingElRoot.querySelector('.modal-shadow')).afterStyles({
                'transform': 'translateY(0) scale(1)'
              }).keyframes([{
                offset: 0,
                opacity: '0',
                transform: _finalTransform2
              }, {
                offset: 1,
                opacity: '1',
                transform: 'translateY(0) scale(1)'
              }]);
              baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
            }
          }
        } else {
          baseAnimation.addAnimation(backdropAnimation);
        }

        return baseAnimation;
      };

      var createEnterAnimation = function createEnterAnimation() {
        var backdropAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().fromTo('opacity', 0.01, 'var(--backdrop-opacity)');
        var wrapperAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().keyframes([{
          offset: 0,
          opacity: 0.01,
          transform: 'translateY(40px)'
        }, {
          offset: 1,
          opacity: 1,
          transform: "translateY(0px)"
        }]);
        return {
          backdropAnimation: backdropAnimation,
          wrapperAnimation: wrapperAnimation
        };
      };
      /**
       * Md Modal Enter Animation
       */


      var mdEnterAnimation = function mdEnterAnimation(baseEl, opts) {
        var currentBreakpoint = opts.currentBreakpoint;
        var root = (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.g)(baseEl);

        var _ref3 = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation(),
            wrapperAnimation = _ref3.wrapperAnimation,
            backdropAnimation = _ref3.backdropAnimation;

        backdropAnimation.addElement(root.querySelector('ion-backdrop')).beforeStyles({
          'pointer-events': 'none'
        }).afterClearStyles(['pointer-events']);
        wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));
        return (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().addElement(baseEl).easing('cubic-bezier(0.36,0.66,0.04,1)').duration(280).addAnimation([backdropAnimation, wrapperAnimation]);
      };

      var createLeaveAnimation = function createLeaveAnimation() {
        var backdropAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().fromTo('opacity', 'var(--backdrop-opacity)', 0);
        var wrapperAnimation = (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().keyframes([{
          offset: 0,
          opacity: 0.99,
          transform: "translateY(0px)"
        }, {
          offset: 1,
          opacity: 0,
          transform: 'translateY(40px)'
        }]);
        return {
          backdropAnimation: backdropAnimation,
          wrapperAnimation: wrapperAnimation
        };
      };
      /**
       * Md Modal Leave Animation
       */


      var mdLeaveAnimation = function mdLeaveAnimation(baseEl, opts) {
        var currentBreakpoint = opts.currentBreakpoint;
        var root = (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.g)(baseEl);

        var _ref4 = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation(),
            wrapperAnimation = _ref4.wrapperAnimation,
            backdropAnimation = _ref4.backdropAnimation;

        backdropAnimation.addElement(root.querySelector('ion-backdrop'));
        wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));
        return (0, _animation_46ad1639_js__WEBPACK_IMPORTED_MODULE_7__.c)().easing('cubic-bezier(0.47,0,0.745,0.715)').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
      };

      var createSheetGesture = function createSheetGesture(baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation) {
        var breakpoints = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
        var onDismiss = arguments.length > 7 ? arguments[7] : undefined;
        var onBreakpointChange = arguments.length > 8 ? arguments[8] : undefined;
        // Defaults for the sheet swipe animation
        var defaultBackdrop = [{
          offset: 0,
          opacity: 'var(--backdrop-opacity)'
        }, {
          offset: 1,
          opacity: 0.01
        }];
        var customBackdrop = [{
          offset: 0,
          opacity: 'var(--backdrop-opacity)'
        }, {
          offset: backdropBreakpoint,
          opacity: 0
        }, {
          offset: 1,
          opacity: 0
        }];
        var SheetDefaults = {
          WRAPPER_KEYFRAMES: [{
            offset: 0,
            transform: 'translateY(0%)'
          }, {
            offset: 1,
            transform: 'translateY(100%)'
          }],
          BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop
        };
        var contentEl = baseEl.querySelector('ion-content');
        var height = wrapperEl.clientHeight;
        var currentBreakpoint = initialBreakpoint;
        var offset = 0;
        var wrapperAnimation = animation.childAnimations.find(function (ani) {
          return ani.id === 'wrapperAnimation';
        });
        var backdropAnimation = animation.childAnimations.find(function (ani) {
          return ani.id === 'backdropAnimation';
        });
        var maxBreakpoint = breakpoints[breakpoints.length - 1];
        /**
         * After the entering animation completes,
         * we need to set the animation to go from
         * offset 0 to offset 1 so that users can
         * swipe in any direction. We then set the
         * animation offset to the current breakpoint
         * so there is no flickering.
         */

        if (wrapperAnimation && backdropAnimation) {
          wrapperAnimation.keyframes(_toConsumableArray(SheetDefaults.WRAPPER_KEYFRAMES));
          backdropAnimation.keyframes(_toConsumableArray(SheetDefaults.BACKDROP_KEYFRAMES));
          animation.progressStart(true, 1 - currentBreakpoint);
          var backdropEnabled = currentBreakpoint >= backdropBreakpoint;
          backdropEl.style.setProperty('pointer-events', backdropEnabled ? 'auto' : 'none');
        }

        if (contentEl && currentBreakpoint !== maxBreakpoint) {
          contentEl.scrollY = false;
        }

        var canStart = function canStart(detail) {
          /**
           * If the sheet is fully expanded and
           * the user is swiping on the content,
           * the gesture should not start to
           * allow for scrolling on the content.
           */
          var content = detail.event.target.closest('ion-content');

          if (currentBreakpoint === 1 && content) {
            return false;
          }

          return true;
        };

        var onStart = function onStart() {
          /**
           * If swiping on the content
           * we should disable scrolling otherwise
           * the sheet will expand and the content will scroll.
           */
          if (contentEl) {
            contentEl.scrollY = false;
          }

          animation.progressStart(true, 1 - currentBreakpoint);
        };

        var onMove = function onMove(detail) {
          /**
           * Given the change in gesture position on the Y axis,
           * compute where the offset of the animation should be
           * relative to where the user dragged.
           */
          var initialStep = 1 - currentBreakpoint;
          offset = (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.j)(0.0001, initialStep + detail.deltaY / height, 0.9999);
          animation.progressStep(offset);
        };

        var onEnd = function onEnd(detail) {
          /**
           * When the gesture releases, we need to determine
           * the closest breakpoint to snap to.
           */
          var velocity = detail.velocityY;
          var threshold = (detail.deltaY + velocity * 100) / height;
          var diff = currentBreakpoint - threshold;
          var closest = breakpoints.reduce(function (a, b) {
            return Math.abs(b - diff) < Math.abs(a - diff) ? b : a;
          });
          var shouldRemainOpen = closest !== 0;
          currentBreakpoint = 0;
          /**
           * Update the animation so that it plays from
           * the last offset to the closest snap point.
           */

          if (wrapperAnimation && backdropAnimation) {
            wrapperAnimation.keyframes([{
              offset: 0,
              transform: "translateY(".concat(offset * 100, "%)")
            }, {
              offset: 1,
              transform: "translateY(".concat((1 - closest) * 100, "%)")
            }]);
            backdropAnimation.keyframes([{
              offset: 0,
              opacity: "calc(var(--backdrop-opacity) * ".concat(getBackdropValueForSheet(1 - offset, backdropBreakpoint), ")")
            }, {
              offset: 1,
              opacity: "calc(var(--backdrop-opacity) * ".concat(getBackdropValueForSheet(closest, backdropBreakpoint), ")")
            }]);
            animation.progressStep(0);
          }
          /**
           * Gesture should remain disabled until the
           * snapping animation completes.
           */


          gesture.enable(false);
          animation.onFinish(function () {
            if (shouldRemainOpen) {
              /**
               * Once the snapping animation completes,
               * we need to reset the animation to go
               * from 0 to 1 so users can swipe in any direction.
               * We then set the animation offset to the current
               * breakpoint so that it starts at the snapped position.
               */
              if (wrapperAnimation && backdropAnimation) {
                (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.r)(function () {
                  wrapperAnimation.keyframes(_toConsumableArray(SheetDefaults.WRAPPER_KEYFRAMES));
                  backdropAnimation.keyframes(_toConsumableArray(SheetDefaults.BACKDROP_KEYFRAMES));
                  animation.progressStart(true, 1 - closest);
                  currentBreakpoint = closest;
                  onBreakpointChange(currentBreakpoint);
                  /**
                   * If the sheet is fully expanded, we can safely
                   * enable scrolling again.
                   */

                  if (contentEl && currentBreakpoint === breakpoints[breakpoints.length - 1]) {
                    contentEl.scrollY = true;
                  }

                  var backdropEnabled = currentBreakpoint >= backdropBreakpoint;
                  backdropEl.style.setProperty('pointer-events', backdropEnabled ? 'auto' : 'none');
                  gesture.enable(true);
                });
              } else {
                gesture.enable(true);
              }
            }
            /**
             * This must be a one time callback
             * otherwise a new callback will
             * be added every time onEnd runs.
             */

          }, {
            oneTimeCallback: true
          }).progressEnd(1, 0, 500);

          if (!shouldRemainOpen) {
            onDismiss();
          }
        };

        var gesture = (0, _index_34cb2743_js__WEBPACK_IMPORTED_MODULE_9__.createGesture)({
          el: wrapperEl,
          gestureName: 'modalSheet',
          gesturePriority: 40,
          direction: 'y',
          threshold: 10,
          canStart: canStart,
          onStart: onStart,
          onMove: onMove,
          onEnd: onEnd
        });
        return gesture;
      };

      var modalIosCss = ":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict;pointer-events:none}:host(.modal-interactive) .modal-wrapper,:host(.modal-interactive) ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);background:var(--ion-color-step-350, #c0c0be);z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host(:first-of-type){--backdrop-opacity:var(--ion-backdrop-opacity, 0.4)}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:10px}}.modal-wrapper{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0)}@media screen and (max-width: 767px){@supports (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - max(30px, var(--ion-safe-area-top)) - 10px)}}@supports not (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - 40px)}}:host(.modal-card) .modal-wrapper{border-top-left-radius:10px;border-top-right-radius:10px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-card) .modal-wrapper,:host-context([dir=rtl]).modal-card .modal-wrapper{border-top-left-radius:10px;border-top-right-radius:10px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host(.modal-card){--backdrop-opacity:0;--width:100%;-ms-flex-align:end;align-items:flex-end}:host(.modal-card) .modal-shadow{display:none}:host(.modal-card) ion-backdrop{pointer-events:none}}@media screen and (min-width: 768px){:host(.modal-card){--width:calc(100% - 120px);--height:calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));--max-width:720px;--max-height:1000px;--backdrop-opacity:0;--box-shadow:0px 0px 30px 10px rgba(0, 0, 0, 0.1);-webkit-transition:all 0.5s ease-in-out;transition:all 0.5s ease-in-out}:host(.modal-card) .modal-shadow{-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}}:host(.modal-sheet) .modal-wrapper{border-top-left-radius:10px;border-top-right-radius:10px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-sheet) .modal-wrapper,:host-context([dir=rtl]).modal-sheet .modal-wrapper{border-top-left-radius:10px;border-top-right-radius:10px;border-bottom-right-radius:0;border-bottom-left-radius:0}";
      var modalMdCss = ":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict;pointer-events:none}:host(.modal-interactive) .modal-wrapper,:host(.modal-interactive) ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);background:var(--ion-color-step-350, #c0c0be);z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host(:first-of-type){--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:2px}:host(:first-of-type){--box-shadow:0 28px 48px rgba(0, 0, 0, 0.4)}}.modal-wrapper{-webkit-transform:translate3d(0,  40px,  0);transform:translate3d(0,  40px,  0);opacity:0.01}";

      var Modal = /*#__PURE__*/function () {
        function Modal(hostRef) {
          var _this = this;

          _classCallCheck(this, Modal);

          (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
          this.didPresent = (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionModalDidPresent", 7);
          this.willPresent = (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionModalWillPresent", 7);
          this.willDismiss = (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionModalWillDismiss", 7);
          this.didDismiss = (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionModalDidDismiss", 7);
          this.didPresentShorthand = (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "didPresent", 7);
          this.willPresentShorthand = (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "willPresent", 7);
          this.willDismissShorthand = (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "willDismiss", 7);
          this.didDismissShorthand = (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "didDismiss", 7);
          this.modalIndex = modalIds++;
          this.coreDelegate = (0, _framework_delegate_780bd731_js__WEBPACK_IMPORTED_MODULE_2__.C)();
          this.isSheetModal = false;
          this.inline = false; // Whether or not modal is being dismissed via gesture

          this.gestureAnimationDismissing = false;
          this.presented = false;
          /**
           * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
           */

          this.keyboardClose = true;
          /**
           * A decimal value between 0 and 1 that indicates the
           * point at which the backdrop will begin to fade in
           * when using a sheet modal. Prior to this point, the
           * backdrop will be hidden and the content underneath
           * the sheet can be interacted with. This value must
           * also be listed in the `breakpoints` array.
           */

          this.backdropBreakpoint = 0;
          /**
           * If `true`, the modal will be dismissed when the backdrop is clicked.
           */

          this.backdropDismiss = true;
          /**
           * If `true`, a backdrop will be displayed behind the modal.
           */

          this.showBackdrop = true;
          /**
           * If `true`, the modal will animate.
           */

          this.animated = true;
          /**
           * If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.
           */

          this.swipeToClose = false;
          /**
           * If `true`, the modal will open. If `false`, the modal will close.
           * Use this if you need finer grained control over presentation, otherwise
           * just use the modalController or the `trigger` property.
           * Note: `isOpen` will not automatically be set back to `false` when
           * the modal dismisses. You will need to do that in your code.
           */

          this.isOpen = false;

          this.configureTriggerInteraction = function () {
            var trigger = _this.trigger,
                el = _this.el,
                destroyTriggerInteraction = _this.destroyTriggerInteraction;

            if (destroyTriggerInteraction) {
              destroyTriggerInteraction();
            }

            var triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;

            if (!triggerEl) {
              return;
            }

            var configureTriggerInteraction = function configureTriggerInteraction(triggerEl, modalEl) {
              var openModal = function openModal() {
                modalEl.present();
              };

              triggerEl.addEventListener('click', openModal);
              return function () {
                triggerEl.removeEventListener('click', openModal);
              };
            };

            _this.destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);
          };

          this.onBackdropTap = function () {
            _this.dismiss(undefined, _overlays_0d94a120_js__WEBPACK_IMPORTED_MODULE_4__.B);
          };

          this.onDismiss = function (ev) {
            ev.stopPropagation();
            ev.preventDefault();

            _this.dismiss();
          };

          this.onLifecycle = function (modalEvent) {
            var el = _this.usersElement;
            var name = LIFECYCLE_MAP[modalEvent.type];

            if (el && name) {
              var ev = new CustomEvent(name, {
                bubbles: false,
                cancelable: false,
                detail: modalEvent.detail
              });
              el.dispatchEvent(ev);
            }
          };
        }

        _createClass(Modal, [{
          key: "onIsOpenChange",
          value: function onIsOpenChange(newValue, oldValue) {
            if (newValue === true && oldValue === false) {
              this.present();
            } else if (newValue === false && oldValue === true) {
              this.dismiss();
            }
          }
        }, {
          key: "onTriggerChange",
          value: function onTriggerChange() {
            this.configureTriggerInteraction();
          }
        }, {
          key: "swipeToCloseChanged",
          value: function swipeToCloseChanged(enable) {
            if (this.gesture) {
              this.gesture.enable(enable);
            } else if (enable) {
              this.initSwipeToClose();
            }
          }
        }, {
          key: "connectedCallback",
          value: function connectedCallback() {
            (0, _overlays_0d94a120_js__WEBPACK_IMPORTED_MODULE_4__.e)(this.el);
          }
        }, {
          key: "componentWillLoad",
          value: function componentWillLoad() {
            var breakpoints = this.breakpoints,
                initialBreakpoint = this.initialBreakpoint;
            /**
             * If user has custom ID set then we should
             * not assign the default incrementing ID.
             */

            this.modalId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : "ion-modal-".concat(this.modalIndex);
            this.isSheetModal = breakpoints !== undefined && initialBreakpoint !== undefined;

            if (breakpoints !== undefined && initialBreakpoint !== undefined && !breakpoints.includes(initialBreakpoint)) {
              console.warn('[Ionic Warning]: Your breakpoints array must include the initialBreakpoint value.');
            }
          }
        }, {
          key: "componentDidLoad",
          value: function componentDidLoad() {
            var _this2 = this;

            /**
             * If modal was rendered with isOpen="true"
             * then we should open modal immediately.
             */
            if (this.isOpen === true) {
              (0, _helpers_684323ee_js__WEBPACK_IMPORTED_MODULE_3__.r)(function () {
                return _this2.present();
              });
            }

            this.configureTriggerInteraction();
          }
          /**
           * Determines whether or not an overlay
           * is being used inline or via a controller/JS
           * and returns the correct delegate.
           * By default, subsequent calls to getDelegate
           * will use a cached version of the delegate.
           * This is useful for calling dismiss after
           * present so that the correct delegate is given.
           */

        }, {
          key: "getDelegate",
          value: function getDelegate() {
            var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            if (this.workingDelegate && !force) {
              return {
                delegate: this.workingDelegate,
                inline: this.inline
              };
            }
            /**
             * If using overlay inline
             * we potentially need to use the coreDelegate
             * so that this works in vanilla JS apps.
             * If a user has already placed the overlay
             * as a direct descendant of ion-app or
             * the body, then we can assume that
             * the overlay is already in the correct place.
             */


            var parentEl = this.el.parentNode;
            var inline = this.inline = parentEl !== null && parentEl.tagName !== 'ION-APP' && parentEl.tagName !== 'BODY';
            var delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;
            return {
              inline: inline,
              delegate: delegate
            };
          }
          /**
           * Present the modal overlay after it has been created.
           */

        }, {
          key: "present",
          value: function () {
            var _present = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var _this3 = this;

              var data, _this$getDelegate, inline, delegate;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!this.presented) {
                        _context.next = 2;
                        break;
                      }

                      return _context.abrupt("return");

                    case 2:
                      if (!(this.currentTransition !== undefined)) {
                        _context.next = 5;
                        break;
                      }

                      _context.next = 5;
                      return this.currentTransition;

                    case 5:
                      data = Object.assign(Object.assign({}, this.componentProps), {
                        modal: this.el
                      });
                      _this$getDelegate = this.getDelegate(true), inline = _this$getDelegate.inline, delegate = _this$getDelegate.delegate;
                      _context.next = 9;
                      return (0, _framework_delegate_780bd731_js__WEBPACK_IMPORTED_MODULE_2__.a)(delegate, this.el, this.component, ['ion-page'], data, inline);

                    case 9:
                      this.usersElement = _context.sent;
                      _context.next = 12;
                      return (0, _index_f51621dd_js__WEBPACK_IMPORTED_MODULE_6__.e)(this.usersElement);

                    case 12:
                      (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.c)(function () {
                        return _this3.el.classList.add('show-modal');
                      });
                      this.currentTransition = (0, _overlays_0d94a120_js__WEBPACK_IMPORTED_MODULE_4__.d)(this, 'modalEnter', iosEnterAnimation, mdEnterAnimation, {
                        presentingEl: this.presentingElement,
                        currentBreakpoint: this.initialBreakpoint,
                        backdropBreakpoint: this.backdropBreakpoint
                      });
                      _context.next = 16;
                      return this.currentTransition;

                    case 16:
                      if (this.isSheetModal) {
                        this.initSheetGesture();
                      } else if (this.swipeToClose) {
                        this.initSwipeToClose();
                      }

                      this.currentTransition = undefined;

                    case 18:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function present() {
              return _present.apply(this, arguments);
            }

            return present;
          }()
        }, {
          key: "initSwipeToClose",
          value: function initSwipeToClose() {
            var _this4 = this;

            if ((0, _ionic_global_e0b8d325_js__WEBPACK_IMPORTED_MODULE_1__.b)(this) !== 'ios') {
              return;
            } // All of the elements needed for the swipe gesture
            // should be in the DOM and referenced by now, except
            // for the presenting el


            var animationBuilder = this.leaveAnimation || _ionic_global_e0b8d325_js__WEBPACK_IMPORTED_MODULE_1__.c.get('modalLeave', iosLeaveAnimation);

            var ani = this.animation = animationBuilder(this.el, {
              presentingEl: this.presentingElement
            });
            this.gesture = createSwipeToCloseGesture(this.el, ani, function () {
              /**
               * While the gesture animation is finishing
               * it is possible for a user to tap the backdrop.
               * This would result in the dismiss animation
               * being played again. Typically this is avoided
               * by setting `presented = false` on the overlay
               * component; however, we cannot do that here as
               * that would prevent the element from being
               * removed from the DOM.
               */
              _this4.gestureAnimationDismissing = true;

              _this4.animation.onFinish( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return _this4.dismiss(undefined, 'gesture');

                      case 2:
                        _this4.gestureAnimationDismissing = false;

                      case 3:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              })));
            });
            this.gesture.enable(true);
          }
        }, {
          key: "initSheetGesture",
          value: function initSheetGesture() {
            var _this5 = this;

            var _a;

            var wrapperEl = this.wrapperEl,
                initialBreakpoint = this.initialBreakpoint,
                backdropBreakpoint = this.backdropBreakpoint;

            if (!wrapperEl || initialBreakpoint === undefined) {
              return;
            }

            var animationBuilder = this.enterAnimation || _ionic_global_e0b8d325_js__WEBPACK_IMPORTED_MODULE_1__.c.get('modalEnter', iosEnterAnimation);

            var ani = this.animation = animationBuilder(this.el, {
              presentingEl: this.presentingElement,
              currentBreakpoint: initialBreakpoint,
              backdropBreakpoint: backdropBreakpoint
            });
            ani.progressStart(true, 1);
            var sortedBreakpoints = ((_a = this.breakpoints) === null || _a === void 0 ? void 0 : _a.sort(function (a, b) {
              return a - b;
            })) || [];
            this.gesture = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, sortedBreakpoints, function () {
              /**
               * While the gesture animation is finishing
               * it is possible for a user to tap the backdrop.
               * This would result in the dismiss animation
               * being played again. Typically this is avoided
               * by setting `presented = false` on the overlay
               * component; however, we cannot do that here as
               * that would prevent the element from being
               * removed from the DOM.
               */
              _this5.gestureAnimationDismissing = true;

              _this5.animation.onFinish( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return _this5.dismiss(undefined, 'gesture');

                      case 2:
                        _this5.gestureAnimationDismissing = false;

                      case 3:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              })));
            }, function (breakpoint) {
              _this5.currentBreakpoint = breakpoint;
            });
            this.gesture.enable(true);
          }
          /**
           * Dismiss the modal overlay after it has been presented.
           *
           * @param data Any data to emit in the dismiss events.
           * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.
           */

        }, {
          key: "dismiss",
          value: function () {
            var _dismiss = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(data, role) {
              var enteringAnimation, dismissed, _this$getDelegate2, delegate;

              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (!(this.gestureAnimationDismissing && role !== 'gesture')) {
                        _context4.next = 2;
                        break;
                      }

                      return _context4.abrupt("return", false);

                    case 2:
                      if (!(this.currentTransition !== undefined)) {
                        _context4.next = 5;
                        break;
                      }

                      _context4.next = 5;
                      return this.currentTransition;

                    case 5:
                      enteringAnimation = _overlays_0d94a120_js__WEBPACK_IMPORTED_MODULE_4__.h.get(this) || [];
                      this.currentTransition = (0, _overlays_0d94a120_js__WEBPACK_IMPORTED_MODULE_4__.f)(this, data, role, 'modalLeave', iosLeaveAnimation, mdLeaveAnimation, {
                        presentingEl: this.presentingElement,
                        currentBreakpoint: this.currentBreakpoint || this.initialBreakpoint,
                        backdropBreakpoint: this.backdropBreakpoint
                      });
                      _context4.next = 9;
                      return this.currentTransition;

                    case 9:
                      dismissed = _context4.sent;

                      if (!dismissed) {
                        _context4.next = 17;
                        break;
                      }

                      _this$getDelegate2 = this.getDelegate(), delegate = _this$getDelegate2.delegate;
                      _context4.next = 14;
                      return (0, _framework_delegate_780bd731_js__WEBPACK_IMPORTED_MODULE_2__.d)(delegate, this.usersElement);

                    case 14:
                      if (this.animation) {
                        this.animation.destroy();
                      }

                      if (this.gesture) {
                        this.gesture.destroy();
                      }

                      enteringAnimation.forEach(function (ani) {
                        return ani.destroy();
                      });

                    case 17:
                      this.currentTransition = undefined;
                      this.animation = undefined;
                      return _context4.abrupt("return", dismissed);

                    case 20:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function dismiss(_x, _x2) {
              return _dismiss.apply(this, arguments);
            }

            return dismiss;
          }()
          /**
           * Returns a promise that resolves when the modal did dismiss.
           */

        }, {
          key: "onDidDismiss",
          value: function onDidDismiss() {
            return (0, _overlays_0d94a120_js__WEBPACK_IMPORTED_MODULE_4__.g)(this.el, 'ionModalDidDismiss');
          }
          /**
           * Returns a promise that resolves when the modal will dismiss.
           */

        }, {
          key: "onWillDismiss",
          value: function onWillDismiss() {
            return (0, _overlays_0d94a120_js__WEBPACK_IMPORTED_MODULE_4__.g)(this.el, 'ionModalWillDismiss');
          }
        }, {
          key: "render",
          value: function render() {
            var _Object$assign,
                _this6 = this;

            var handle = this.handle,
                isSheetModal = this.isSheetModal,
                presentingElement = this.presentingElement,
                htmlAttributes = this.htmlAttributes;
            var showHandle = handle !== false && isSheetModal;
            var mode = (0, _ionic_global_e0b8d325_js__WEBPACK_IMPORTED_MODULE_1__.b)(this);
            var presented = this.presented,
                modalId = this.modalId;
            return (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.H, Object.assign({
              "no-router": true,
              "aria-modal": "true",
              tabindex: "-1"
            }, htmlAttributes, {
              style: {
                zIndex: "".concat(20000 + this.overlayIndex)
              },
              "class": Object.assign((_Object$assign = {}, _defineProperty(_Object$assign, mode, true), _defineProperty(_Object$assign, "modal-card", presentingElement !== undefined && mode === 'ios'), _defineProperty(_Object$assign, "modal-sheet", isSheetModal), _defineProperty(_Object$assign, 'overlay-hidden', true), _defineProperty(_Object$assign, 'modal-interactive', presented), _Object$assign), (0, _theme_ff3fc52f_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.cssClass)),
              id: modalId,
              onIonBackdropTap: this.onBackdropTap,
              onIonDismiss: this.onDismiss,
              onIonModalDidPresent: this.onLifecycle,
              onIonModalWillPresent: this.onLifecycle,
              onIonModalWillDismiss: this.onLifecycle,
              onIonModalDidDismiss: this.onLifecycle
            }), (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.h)("ion-backdrop", {
              ref: function ref(el) {
                return _this6.backdropEl = el;
              },
              visible: this.showBackdrop,
              tappable: this.backdropDismiss,
              part: "backdrop"
            }), mode === 'ios' && (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
              "class": "modal-shadow"
            }), (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
              role: "dialog",
              "class": "modal-wrapper ion-overlay-wrapper",
              part: "content",
              ref: function ref(el) {
                return _this6.wrapperEl = el;
              }
            }, showHandle && (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
              "class": "modal-handle",
              part: "handle"
            }), (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null)));
          }
        }, {
          key: "el",
          get: function get() {
            return (0, _index_8fc7a46a_js__WEBPACK_IMPORTED_MODULE_0__.i)(this);
          }
        }], [{
          key: "watchers",
          get: function get() {
            return {
              "isOpen": ["onIsOpenChange"],
              "trigger": ["onTriggerChange"],
              "swipeToClose": ["swipeToCloseChanged"]
            };
          }
        }]);

        return Modal;
      }();

      var LIFECYCLE_MAP = {
        'ionModalDidPresent': 'ionViewDidEnter',
        'ionModalWillPresent': 'ionViewWillEnter',
        'ionModalWillDismiss': 'ionViewWillLeave',
        'ionModalDidDismiss': 'ionViewDidLeave'
      };
      var modalIds = 0;
      Modal.style = {
        ios: modalIosCss,
        md: modalMdCss
      };
      /***/
    }
  }]);
})();
//# sourceMappingURL=node_modules_ionic_core_dist_esm_ion-modal_entry_js-es5.js.map